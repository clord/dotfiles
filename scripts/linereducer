#!/usr/bin/env ruby

# Do a line-based reduction of a file, using an external script as the condition


# ARGV[0] is the input file being reduced, and ARGV[1] is the condition script This tool does not modify the input files, but instead produces "best.#{f}" and "current.#{f}". the later is passed as an argument to the condition script, which decides whether the that file is "interesting" or not. exit code zero indicate interesting. If the script returns zero, this script (the reducer) will update 'best' and then produce a new candidate.
# This script proceeds as a fixpoint algorithm, trying to remove all permutations of  lines. 
# Also, the initial run of the script is used to determine a 'runtime' for the condition script. If any particular invocation of it takes more than twice the original runtime, it will be terminated as uninteresting. this helps avoid introducing infinite loops. 
require 'fileutils'
include FileUtils

raise "Argument expected" if ARGV.length != 2
original  = ARGV[0]
condition = ARGV[1]

raise "Input file must exist and be readable" unless File.readable? original
raise "Working directory must be writable" unless File.writable? pwd
raise "#{condition} must be executable" unless File.executable? condition
raise "#{condition} must return zero on #{original}" unless system(condition, original)

# Generate our extension-preserving best/current names
oname = File.basename(original)
currentName = "current.#{oname}"
bestName = "best.#{oname}"
bestIterName = "best.iter.#{oname}"
cp original, bestName

# Start with groups of filelines/10 lines. This takes out the bulk of crap that we don't actually need. 
# Then, try replacing blocks ({}) with semicolons. 
# Then, try groups of n lines (n from 20 to 1 in sequence)
# If we've not changed the file since the last loop, break

class Reducer

   def makeCandidate(best, i)
      best # Just copy in the default path
   end

   def writeCandidate(lines, cand)
      begin
         # Write the lines to cand
         File.open("#{cand}.tmp", mode="w") do |f|
            lines.each do |l|
               f.write l
            end
         end
         return lines
      ensure
         mv "#{cand}.tmp", cand
      end
   end

   def makeCandidates(best)
      curbest = best.clone
      (curbest.length / (1 + 50 * Math.log(curbest.length.to_f) ** 2).to_i).times do |i|
         red = makeCandidate(curbest, i)
         curbest = (yield red).clone
      end
      return curbest
   end
end


# blocks are regions of the file delimited with matching braces
class Blocks < Reducer
   
end


class LineScanner < Reducer
   attr_accessor :n
   
   def initialize(n)
      @n = n
   end
   
   def makeCandidates(best)
      curbest = best.clone
      (curbest.count / n).times do |i|
         red = makeCandidate(curbest, i * n)
         curbest = (yield red).clone
      end
      return curbest
   end
   
   def makeCandidate(lines, start)
      lines.slice!(start, n)
      lines
   end
   
end


class LineGroup < Reducer
   attr_accessor :n
   
   def initialize(n)
      @n = n
   end
   
   def makeCandidate(lines, i)
      srand(i * lines.length)
      n.times do
         idx = (rand * lines.length).to_i
         lines.delete_at(idx)
      end
      lines
   end
   
end


# Chunks are portions of a file (argument is the factor to use) for example, p=0.1 means we'll divide the file into 10 parts, and produce one of 10 possible candidates
class Chunks < Reducer
   attr_accessor :p
   
   def initialize(p)
      @p = p
   end
   
   def makeCandidate(lines, i)
      srand(i * lines.length)
      start = (rand * lines.length).to_i - (lines.length * p).to_i
      lines.slice!(start, (lines.length * p).to_i)
      lines
   end
   
end

phases = [ [Chunks.new(0.1),
            Chunks.new(0.05),
            LineGroup.new(500)],
           [Chunks.new(0.01),
            Chunks.new(0.001),
            LineGroup.new(50)],
           [LineScanner.new(20),
            LineScanner.new(5),
            LineScanner.new(1)]
           ]

originalLen = File.stat(original).size

def fixpoint(reducers, originalLen, condition, bestName, bestIterName, currentName)
   while true do
      cp bestName, bestIterName
      start = File.stat(bestName).size
      shrunk = false
      reducers.each do |reducer|
         lines = IO.readlines(bestName)
         reducer.makeCandidates(lines) do |redlines|
            this_shrunk = lines
            if lines.count > redlines.count
               reducer.writeCandidate(redlines, currentName)
               if system(condition, currentName)
                  lines = redlines
                  cp currentName, bestName
                  shrunk = true
                  this_shrunk = redlines
               end
            end
            this_shrunk
         end
      end
      endsize = File.stat(bestName).size
      puts "  Shrunk by #{start - endsize} bytes (to #{endsize}: #{(100*((endsize * 1.0)/originalLen)).to_i}% of original size)"
      break unless shrunk
   end
   !compare_file(bestIterName, bestName)
end

# Our outer fixed-point loop
while true do
   res = false
   phasenum = 0
   phases.each do |phase|
      phasenum += 1
      puts "Phase #{phasenum}"
      res = fixpoint(phase, originalLen, condition, bestName, bestIterName, currentName)
   end
   break unless res
end

# Finished, all of the reducers have run, and in theory at least currentName is the minimal file
# Exit normally.


